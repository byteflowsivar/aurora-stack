#!/usr/bin/env node

/**
 * 03-create-sample-issues.js
 * 
 * Script para crear issues de ejemplo y plantillas para el proyecto Aurora Stack
 * 
 * PROP√ìSITO:
 * - Crear issues de ejemplo que demuestren el uso de los campos personalizados
 * - Establecer plantillas para diferentes tipos de issues
 * - Crear los Epics principales basados en la documentaci√≥n del proyecto
 * - Demostrar buenas pr√°cticas en la creaci√≥n de issues
 * 
 * ISSUES QUE CREA:
 * - Epics principales del proyecto Aurora Stack
 * - Issues de ejemplo por cada componente
 * - Tasks espec√≠ficas con estimaciones de tiempo y costo
 * 
 * ESTRUCTURA:
 * 1. Epics (issues grandes que agrupan work)
 * 2. Features (funcionalidades espec√≠ficas)
 * 3. Tasks (tareas t√©cnicas concretas)
 * 4. Bugs (ejemplos de reporte de errores)
 * 
 * PREREQUISITOS:
 * - Scripts 01 y 02 ejecutados previamente
 * - GitHub CLI instalado y autenticado
 * - Proyecto y etiquetas ya configurados
 */

const { execSync } = require('child_process');
const { join } = require('path');

// Cargar variables de entorno desde .env
require('dotenv').config({ path: join(__dirname, '.env') });

// Configuraci√≥n del repositorio
const CONFIG = {
  REPO_OWNER: process.env.GITHUB_OWNER,
  REPO_NAME: process.env.REPO_NAME || 'aurora-stack',
  OWNER_TYPE: process.env.GITHUB_OWNER_TYPE || 'user',
  HOURLY_RATE: parseFloat(process.env.HOURLY_RATE || '30'),

  // Issues de ejemplo a crear
  SAMPLE_ISSUES: [
    // === EPICS PRINCIPALES ===
    {
      title: '[EPIC] Configuraci√≥n de Infraestructura Base',
      body: `## Descripci√≥n
Configurar toda la infraestructura base del proyecto Aurora Stack incluyendo containerizaci√≥n, bases de datos y networking.

## üìã Tareas para Completar este Epic
- [ ] Configurar Docker Compose para todos los servicios
- [ ] Setup PostgreSQL para Keycloak  
- [ ] Setup PostgreSQL para Aurora
- [ ] Establecer redes Docker aisladas
- [ ] Configurar health checks y monitoring b√°sico
- [ ] Documentar proceso de despliegue

## Criterios de Aceptaci√≥n
- Todos los servicios inician correctamente con \`docker compose up\`
- Las bases de datos est√°n aisladas y configuradas
- La documentaci√≥n est√° actualizada

## üìä Estimaci√≥n
- **Story Points**: 13
- **Horas Estimadas**: 40
- **Costo Estimado**: $1200 (40h √ó $30/h)

## üîó Dependencias
- Ninguna (Epic inicial)

## üìù Notas
Este epic se considera **COMPLETADO** cuando todas las tareas arriba est√©n marcadas como ‚úÖ.

**Progreso**: 0/6 tareas completadas`,
      labels: ['effort: epic', 'type: infrastructure', 'priority: high', 'component: docker'],
      assignees: [],
      milestone: null,
      isEpic: true,
      subtasks: [
        'Configurar Docker Compose para todos los servicios',
        'Setup PostgreSQL para Keycloak',
        'Setup PostgreSQL para Aurora',
        'Establecer redes Docker aisladas',
        'Configurar health checks y monitoring b√°sico',
        'Documentar proceso de despliegue'
      ]
    },

    {
      title: '[EPIC] Integraci√≥n con Keycloak',
      body: `## Descripci√≥n
Implementar la integraci√≥n completa con Keycloak para autenticaci√≥n y autorizaci√≥n en Aurora Stack.

## Objetivos
- [ ] Configurar Keycloak server
- [ ] Crear temas personalizados Aurora
- [ ] Configurar realms y clients
- [ ] Implementar flows de autenticaci√≥n
- [ ] Integrar con aplicaciones Aurora

## Criterios de Aceptaci√≥n
- Keycloak est√° funcionando con tema personalizado
- Los usuarios pueden autenticarse correctamente
- Las aplicaciones Aurora usan Keycloak para auth

## Estimaci√≥n
- **Story Points**: 21
- **Horas Estimadas**: 60
- **Costo Estimado**: $1800 (60h √ó $30/h)

## Dependencias
- Epic de Infraestructura Base

## Referencias
- Documentaci√≥n: \`docs/02-diseno/0201-keycloak/\`
- Tema personalizado: \`packages/keycloak-themes/\``,
      labels: ['effort: epic', 'type: feature', 'priority: high', 'component: keycloak'],
      assignees: [],
      milestone: null
    },

    // === FEATURES ESPEC√çFICAS ===
    {
      title: 'Implementar tema personalizado Aurora para Keycloak',
      body: `## Descripci√≥n
Crear un tema personalizado para Keycloak que refleje la identidad visual de Aurora Stack.

## Tareas
- [ ] Dise√±ar p√°gina de login siguiendo mockups
- [ ] Implementar estilos CSS personalizados
- [ ] Configurar colores y tipograf√≠as Aurora
- [ ] Crear assets (logos, √≠conos)
- [ ] Probar tema en diferentes dispositivos

## Criterios de Aceptaci√≥n
- La p√°gina de login usa los colores y dise√±o Aurora
- El tema es responsive
- Funciona correctamente en navegadores modernos

## Referencias T√©cnicas
- Mockup: \`docs/02-diseno/0201-keycloak/img/login-base.png\`
- Paleta: \`docs/02-diseno/0201-keycloak/img/color-palette.png\`
- Config: \`docs/02-diseno/0201-keycloak/configuracion-tema-aurora.md\`

## Estimaci√≥n
- **Story Points**: 5
- **Horas Estimadas**: 16
- **Costo Estimado**: $480`,
      labels: ['type: feature', 'component: keycloak', 'priority: medium'],
      assignees: [],
      milestone: null
    },

    {
      title: 'Configurar PostgreSQL con health checks y backups',
      body: `## Descripci√≥n
Configurar las instancias de PostgreSQL con monitoreo de salud y estrategia de backups.

## Tareas T√©cnicas
- [ ] Configurar health checks en docker-compose
- [ ] Implementar script de backup autom√°tico
- [ ] Configurar retention policy para backups
- [ ] Documentar proceso de recovery
- [ ] Crear alertas b√°sicas de monitoreo

## Criterios de Aceptaci√≥n
- Health checks funcionan correctamente
- Backups se ejecutan autom√°ticamente
- La documentaci√≥n de recovery est√° completa

## Estimaci√≥n
- **Story Points**: 8
- **Horas Estimadas**: 24
- **Costo Estimado**: $720`,
      labels: ['type: infrastructure', 'component: database', 'priority: medium'],
      assignees: [],
      milestone: null
    },

    // === TASKS ESPEC√çFICAS ===
    {
      title: 'Actualizar documentaci√≥n de configuraci√≥n de entorno',
      body: `## Descripci√≥n
Actualizar la documentaci√≥n del archivo .env y proceso de configuraci√≥n inicial.

## Tareas
- [ ] Documentar todas las variables de entorno
- [ ] Crear ejemplos para diferentes entornos (dev, staging, prod)
- [ ] Actualizar README con instrucciones paso a paso
- [ ] Validar que las instrucciones funcionan desde cero

## Archivos a Actualizar
- \`env.example\`
- \`README.md\`
- \`docs/03-implementacion/0302-guias-desarrollo/\`

## Estimaci√≥n
- **Story Points**: 2
- **Horas Estimadas**: 4
- **Costo Estimado**: $120`,
      labels: ['type: documentation', 'effort: quick-win', 'priority: low'],
      assignees: [],
      milestone: null
    },

    {
      title: 'Configurar CI/CD pipeline b√°sico',
      body: `## Descripci√≥n
Implementar un pipeline b√°sico de CI/CD usando GitHub Actions.

## Funcionalidades
- [ ] Linting autom√°tico de c√≥digo
- [ ] Testing de servicios Docker
- [ ] Build y validaci√≥n de im√°genes
- [ ] Deploy autom√°tico a staging

## Archivos a Crear
- \`.github/workflows/ci.yml\`
- \`.github/workflows/cd.yml\`
- Scripts de testing en \`scripts/\`

## Estimaci√≥n
- **Story Points**: 13
- **Horas Estimadas**: 32
- **Costo Estimado**: $960`,
      labels: ['type: infrastructure', 'component: docker', 'priority: medium'],
      assignees: [],
      milestone: null
    },

    // === EJEMPLO DE BUG ===
    {
      title: 'Error de conexi√≥n a base de datos Keycloak en primer inicio',
      body: `## Descripci√≥n del Bug
Al ejecutar \`docker compose up\` por primera vez, Keycloak falla porque intenta conectar a PostgreSQL antes de que est√© listo.

## Pasos para Reproducir
1. Clonar repositorio limpio
2. Configurar \`.env\` seg√∫n \`env.example\`
3. Ejecutar \`docker compose up\`
4. Observar logs de keycloak

## Comportamiento Actual
Keycloak falla con error de conexi√≥n y se reinicia m√∫ltiples veces.

## Comportamiento Esperado
Keycloak debe esperar a que PostgreSQL est√© listo antes de iniciar.

## Soluci√≥n Propuesta
- [ ] Agregar \`depends_on\` con condition healthy
- [ ] Mejorar health check de PostgreSQL
- [ ] Agregar retry logic en Keycloak

## Estimaci√≥n
- **Story Points**: 3
- **Horas Estimadas**: 6
- **Costo Estimado**: $180`,
      labels: ['type: bug', 'priority: high', 'component: docker', 'component: keycloak'],
      assignees: [],
      milestone: null
    }
  ]
};

/**
 * Ejecuta un comando de GitHub CLI con timeout
 * @param {string} command - Comando a ejecutar
 * @returns {string} - Salida del comando
 */
function runGhCommand(command) {
  try {
    const result = execSync(command, {
      encoding: 'utf-8',
      timeout: 30000, // 30 segundos timeout
      stdio: 'pipe'   // Capturar salida
    });
    return result.trim();
  } catch (error) {
    if (error.status === 'TIMEOUT') {
      throw new Error(`Comando timeout despu√©s de 30 segundos: ${command}`);
    }
    console.error(`Error ejecutando comando: ${command}`);
    console.error(error.message);
    throw error;
  }
}

/**
 * Verifica si GitHub CLI est√° instalado y autenticado
 */
function checkPrerequisites() {
  console.log('üîç Verificando prerequisitos...');

  try {
    runGhCommand('gh --version');
    console.log('‚úÖ GitHub CLI instalado');
  } catch (error) {
    console.error('‚ùå GitHub CLI no est√° instalado. Inst√°lalo con: brew install gh');
    process.exit(1);
  }

  try {
    runGhCommand('gh auth status');
    console.log('‚úÖ GitHub CLI autenticado');
  } catch (error) {
    console.error('‚ùå GitHub CLI no est√° autenticado. Ejecuta: gh auth login');
    process.exit(1);
  }
}

/**
 * Crea un issue en el repositorio usando archivo temporal para el body
 * @param {object} issue - Configuraci√≥n del issue
 * @returns {string} - URL del issue creado
 */
function createIssue(issue) {
  console.log(`üìù Creando issue: ${issue.title}`);

  try {
    const { writeFileSync, unlinkSync } = require('fs');
    const { join } = require('path');
    const os = require('os');

    // Crear archivo temporal para el body (evita problemas con comandos largos)
    const tempFile = join(os.tmpdir(), `issue-body-${Date.now()}.md`);
    writeFileSync(tempFile, issue.body, 'utf8');

    // Preparar comando base usando archivo temporal
    let command = `gh issue create --repo ${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}`;
    command += ` --title "${issue.title.replace(/"/g, '\\"')}"`;
    command += ` --body-file "${tempFile}"`;

    // Agregar etiquetas
    if (issue.labels && issue.labels.length > 0) {
      command += ` --label "${issue.labels.join(',')}"`;
    }

    // Agregar assignees si los hay
    if (issue.assignees && issue.assignees.length > 0) {
      command += ` --assignee "${issue.assignees.join(',')}"`;
    }

    // Agregar milestone si lo hay
    if (issue.milestone) {
      command += ` --milestone "${issue.milestone}"`;
    }

    console.log(`   Ejecutando: gh issue create --title "${issue.title}" --body-file [temp] ...`);
    const result = runGhCommand(command);

    // Limpiar archivo temporal
    try {
      unlinkSync(tempFile);
    } catch (cleanupError) {
      console.warn(`‚ö†Ô∏è  No se pudo limpiar archivo temporal: ${tempFile}`);
    }

    console.log(`‚úÖ Issue creado: ${result}`);
    return result;

  } catch (error) {
    console.error(`‚ùå Error creando issue '${issue.title}': ${error.message}`);
    return null;
  }
}

/**
 * Verifica si ya existen issues similares
 * @returns {Array} - Lista de issues existentes
 */
function getExistingIssues() {
  console.log('üîç Verificando issues existentes...');

  try {
    const command = `gh issue list --repo ${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME} --state all --limit 100`;
    const result = runGhCommand(command);

    const issues = result.split('\n').filter(line => line.trim()).map(line => {
      const parts = line.split('\t');
      return {
        number: parts[0],
        title: parts[2] || '',
        state: parts[1] || ''
      };
    });

    console.log(`‚úÖ Encontrados ${issues.length} issues existentes`);
    return issues;

  } catch (error) {
    console.warn('‚ö†Ô∏è  No se pudieron obtener issues existentes');
    return [];
  }
}

/**
 * Genera reporte de issues creados
 * @param {Array} createdIssues - Issues creados exitosamente
 */
function generateReport(createdIssues) {
  console.log('\nüìä REPORTE DE ISSUES CREADOS\n');

  const categories = [
    { title: 'üèîÔ∏è EPICS', filter: issue => issue.title.includes('[EPIC]') },
    { title: '‚ú® FEATURES', filter: issue => issue.labels?.includes('type: feature') && !issue.title.includes('[EPIC]') },
    { title: 'üîß INFRASTRUCTURE', filter: issue => issue.labels?.includes('type: infrastructure') && !issue.title.includes('[EPIC]') },
    { title: 'üìö DOCUMENTATION', filter: issue => issue.labels?.includes('type: documentation') },
    { title: 'üêõ BUGS', filter: issue => issue.labels?.includes('type: bug') }
  ];

  categories.forEach(category => {
    const issues = CONFIG.SAMPLE_ISSUES.filter(category.filter);
    if (issues.length > 0) {
      console.log(category.title);
      issues.forEach(issue => {
        const url = createdIssues.find(created => created.title === issue.title)?.url || 'No creado';
        console.log(`   ‚Ä¢ ${issue.title}`);
        console.log(`     URL: ${url}`);
      });
      console.log('');
    }
  });

  // Estad√≠sticas
  const totalEstimatedHours = CONFIG.SAMPLE_ISSUES
    .map(issue => {
      const match = issue.body.match(/\*\*Horas Estimadas\*\*: (\d+)/);
      return match ? parseInt(match[1]) : 0;
    })
    .reduce((sum, hours) => sum + hours, 0);

  const totalCost = CONFIG.SAMPLE_ISSUES
    .map(issue => {
      const match = issue.body.match(/\*\*Costo Estimado\*\*: \$(\d+)/);
      return match ? parseInt(match[1]) : 0;
    })
    .reduce((sum, cost) => sum + cost, 0);

  console.log('üí∞ RESUMEN DE ESTIMACIONES');
  console.log(`   Total Horas: ${totalEstimatedHours}h`);
  console.log(`   Costo Total: $${totalCost}`);
  console.log(`   Promedio por hora: $${totalCost / totalEstimatedHours || 0}`);
}

/**
 * Crea sub-issues para un epic y actualiza el epic con referencias
 * @param {object} epic - Epic issue
 * @param {string} epicUrl - URL del epic creado
 */
function createSubIssuesForEpic(epic, epicUrl) {
  if (!epic.isEpic || !epic.subtasks) return;

  console.log(`\nüìã Creando sub-issues para epic: ${epic.title}`);
  const subIssueUrls = [];

  epic.subtasks.forEach((subtask, index) => {
    const subIssue = {
      title: `${subtask}`,
      body: `## Descripci√≥n
${subtask}

## Epic Principal
Este issue forma parte del epic: ${epicUrl}

## Criterios de Aceptaci√≥n
- [ ] Implementar funcionalidad requerida
- [ ] Escribir documentaci√≥n
- [ ] Actualizar epic principal marcando esta tarea como completada

## üìä Estimaci√≥n
- **Story Points**: 3
- **Horas Estimadas**: ${Math.ceil(40 / epic.subtasks.length)}
- **Costo Estimado**: $${Math.ceil(2000 / epic.subtasks.length)}

## üîó Enlaces
- Epic Principal: ${epicUrl}`,
      labels: ['type: feature', 'priority: medium', ...epic.labels.filter(l => l.startsWith('component:'))],
      assignees: [],
      milestone: null
    };

    const subUrl = createIssue(subIssue);
    if (subUrl) {
      subIssueUrls.push(subUrl);
      console.log(`   ‚úÖ Sub-issue ${index + 1}/${epic.subtasks.length}: ${subUrl}`);
    }
  });

  // Actualizar epic con referencias a sub-issues
  if (subIssueUrls.length > 0) {
    console.log(`\nüîó Actualizando epic con referencias a ${subIssueUrls.length} sub-issues`);
    updateEpicWithSubIssues(epicUrl, epic, subIssueUrls);
  }
}

/**
 * Actualiza un epic con referencias a sus sub-issues
 * @param {string} epicUrl - URL del epic
 * @param {object} epic - Configuraci√≥n del epic
 * @param {Array} subIssueUrls - URLs de los sub-issues
 */
function updateEpicWithSubIssues(epicUrl, epic, subIssueUrls) {
  try {
    // Extraer n√∫mero del issue del URL
    const epicNumber = epicUrl.split('/').pop();

    // Crear tasklist con referencias a sub-issues
    const issueNumbers = subIssueUrls.map(url => url.split('/').pop());
    const taskList = epic.subtasks.map((task, index) =>
      `- [ ] ${task} #${issueNumbers[index]}`
    ).join('\n');

    const updatedBody = epic.body.replace(
      /## üìã Tareas para Completar este Epic[\s\S]*?## Criterios/,
      `## üìã Tareas para Completar este Epic
${taskList}

## Criterios`
    );

    // Actualizar el issue usando GitHub CLI
    const { writeFileSync, unlinkSync } = require('fs');
    const { join } = require('path');
    const os = require('os');

    const tempFile = join(os.tmpdir(), `epic-update-${Date.now()}.md`);
    writeFileSync(tempFile, updatedBody, 'utf8');

    const command = `gh issue edit ${epicNumber} --repo ${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME} --body-file "${tempFile}"`;
    runGhCommand(command);

    unlinkSync(tempFile);
    console.log(`   ‚úÖ Epic actualizado con referencias a sub-issues`);

  } catch (error) {
    console.error(`   ‚ùå Error actualizando epic: ${error.message}`);
  }
}

/**
 * Funci√≥n principal
 */
function main() {
  console.log('üìù Iniciando creaci√≥n de issues de ejemplo para Aurora Stack');
  console.log(`üìÅ Repositorio: ${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}\n`);

  // Verificar prerequisitos
  checkPrerequisites();

  // Obtener issues existentes
  const existingIssues = getExistingIssues();

  // Crear issues
  console.log('\nüìù Creando issues de ejemplo...');
  const createdIssues = [];

  CONFIG.SAMPLE_ISSUES.forEach(issue => {
    // Verificar si ya existe un issue similar
    const exists = existingIssues.some(existing =>
      existing.title.toLowerCase().includes(issue.title.toLowerCase().substring(0, 20))
    );

    if (!exists) {
      const url = createIssue(issue);
      if (url) {
        createdIssues.push({
          title: issue.title,
          url,
          labels: issue.labels,
          isEpic: issue.isEpic,
          subtasks: issue.subtasks,
          issue: issue
        });
      }
    } else {
      console.log(`‚ö†Ô∏è  Issue similar ya existe: ${issue.title}`);
    }
  });

  // Crear sub-issues para epics
  const epics = createdIssues.filter(issue => issue.isEpic);
  if (epics.length > 0) {
    console.log('\nüèîÔ∏è  Procesando epics para crear sub-issues...');
    epics.forEach(epicData => {
      createSubIssuesForEpic(epicData.issue, epicData.url);
    });
  }

  // Generar reporte
  generateReport(createdIssues);

  console.log('\n‚úÖ ¬°Creaci√≥n de issues completada!');
  console.log('\nüéØ Pr√≥ximos pasos:');
  console.log('   1. Ejecutar: node 04-setup-project-views.js');
  console.log('   2. Revisar los issues creados en GitHub');
  console.log('   3. Asignar issues a miembros del equipo');
  console.log('   4. Al completar sub-issues, marcar checkboxes en los epics');
}

// Ejecutar solo si es llamado directamente
if (require.main === module) {
  main();
}

module.exports = { CONFIG, runGhCommand, checkPrerequisites };